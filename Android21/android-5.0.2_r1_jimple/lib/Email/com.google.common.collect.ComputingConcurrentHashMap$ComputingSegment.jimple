final class com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment extends com.google.common.collect.MapMakerInternalMap$Segment
{

    void <init>(com.google.common.collect.MapMakerInternalMap, int, int)
    {
        com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment r0;
        com.google.common.collect.MapMakerInternalMap r1;
        int i0, i1;

        r0 := @this: com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment;

        r1 := @parameter0: com.google.common.collect.MapMakerInternalMap;

        i0 := @parameter1: int;

        i1 := @parameter2: int;

        specialinvoke r0.<com.google.common.collect.MapMakerInternalMap$Segment: void <init>(com.google.common.collect.MapMakerInternalMap,int,int)>(r1, i0, i1);

        return;
    }

    java.lang.Object getOrCompute(java.lang.Object, int, com.google.common.base.Function) throws java.util.concurrent.ExecutionException
    {
        com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment r0;
        java.lang.Object r1, r4, r5, r8, r10, r11, $r14, r30, r31, r32;
        int i0, i1, i2, $i3, $i4, $i5, $i6;
        com.google.common.base.Function r2;
        com.google.common.collect.MapMakerInternalMap$ReferenceEntry r3, r7;
        java.util.concurrent.atomic.AtomicReferenceArray r6;
        com.google.common.collect.MapMakerInternalMap$ValueReference r9, $r15, $r20, $r25;
        java.lang.Throwable r12, r13, $r27, $r28;
        boolean $z0, $z1, $z2, $z3, $z4, $z5, $z8, z9;
        com.google.common.collect.ComputingConcurrentHashMap$ComputingValueReference $r16, r29;
        com.google.common.collect.MapMakerInternalMap $r17, $r19, $r22;
        com.google.common.base.Equivalence $r18;
        com.google.common.collect.MapMaker$RemovalCause $r21, $r26;
        java.util.Queue $r23, $r24;

        r0 := @this: com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment;

        r1 := @parameter0: java.lang.Object;

        i0 := @parameter1: int;

        r2 := @parameter2: com.google.common.base.Function;

     label01:
        r3 = virtualinvoke r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: com.google.common.collect.MapMakerInternalMap$ReferenceEntry getEntry(java.lang.Object,int)>(r1, i0);

        if r3 == null goto label03;

        r4 = virtualinvoke r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: java.lang.Object getLiveValue(com.google.common.collect.MapMakerInternalMap$ReferenceEntry)>(r3);

        if r4 == null goto label03;

        virtualinvoke r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: void recordRead(com.google.common.collect.MapMakerInternalMap$ReferenceEntry)>(r3);

        r5 = r4;

     label02:
        virtualinvoke r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: void postReadCleanup()>();

        return r5;

     label03:
        if r3 == null goto label04;

        $r25 = interfaceinvoke r3.<com.google.common.collect.MapMakerInternalMap$ReferenceEntry: com.google.common.collect.MapMakerInternalMap$ValueReference getValueReference()>();

        $z8 = interfaceinvoke $r25.<com.google.common.collect.MapMakerInternalMap$ValueReference: boolean isComputingReference()>();

        if $z8 != 0 goto label21;

     label04:
        z9 = 1;

        r29 = null;

        virtualinvoke r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: void lock()>();

     label05:
        virtualinvoke r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: void preWriteCleanup()>();

        $i4 = r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: int count>;

        i1 = $i4 - 1;

        r6 = r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: java.util.concurrent.atomic.AtomicReferenceArray table>;

        $i3 = virtualinvoke r6.<java.util.concurrent.atomic.AtomicReferenceArray: int length()>();

        $i5 = $i3 - 1;

        i2 = i0 & $i5;

        $r14 = virtualinvoke r6.<java.util.concurrent.atomic.AtomicReferenceArray: java.lang.Object get(int)>(i2);

        r7 = (com.google.common.collect.MapMakerInternalMap$ReferenceEntry) $r14;

        r3 = r7;

     label06:
        if r3 == null goto label14;

        r8 = interfaceinvoke r3.<com.google.common.collect.MapMakerInternalMap$ReferenceEntry: java.lang.Object getKey()>();

        $i6 = interfaceinvoke r3.<com.google.common.collect.MapMakerInternalMap$ReferenceEntry: int getHash()>();

        if $i6 != i0 goto label13;

        if r8 == null goto label13;

        $r17 = r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: com.google.common.collect.MapMakerInternalMap map>;

        $r18 = $r17.<com.google.common.collect.MapMakerInternalMap: com.google.common.base.Equivalence keyEquivalence>;

        $z2 = virtualinvoke $r18.<com.google.common.base.Equivalence: boolean equivalent(java.lang.Object,java.lang.Object)>(r1, r8);

        if $z2 == 0 goto label13;

        r9 = interfaceinvoke r3.<com.google.common.collect.MapMakerInternalMap$ReferenceEntry: com.google.common.collect.MapMakerInternalMap$ValueReference getValueReference()>();

        $z3 = interfaceinvoke r9.<com.google.common.collect.MapMakerInternalMap$ValueReference: boolean isComputingReference()>();

        if $z3 == 0 goto label07;

        z9 = 0;

        goto label14;

     label07:
        $r20 = interfaceinvoke r3.<com.google.common.collect.MapMakerInternalMap$ReferenceEntry: com.google.common.collect.MapMakerInternalMap$ValueReference getValueReference()>();

        r10 = interfaceinvoke $r20.<com.google.common.collect.MapMakerInternalMap$ValueReference: java.lang.Object get()>();

        if r10 != null goto label08;

        $r26 = <com.google.common.collect.MapMaker$RemovalCause: com.google.common.collect.MapMaker$RemovalCause COLLECTED>;

        virtualinvoke r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: void enqueueNotification(java.lang.Object,int,java.lang.Object,com.google.common.collect.MapMaker$RemovalCause)>(r8, i0, r10, $r26);

        goto label12;

     label08:
        $r19 = r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: com.google.common.collect.MapMakerInternalMap map>;

        $z5 = virtualinvoke $r19.<com.google.common.collect.MapMakerInternalMap: boolean expires()>();

        if $z5 == 0 goto label09;

        $r22 = r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: com.google.common.collect.MapMakerInternalMap map>;

        $z4 = virtualinvoke $r22.<com.google.common.collect.MapMakerInternalMap: boolean isExpired(com.google.common.collect.MapMakerInternalMap$ReferenceEntry)>(r3);

        if $z4 == 0 goto label09;

        $r21 = <com.google.common.collect.MapMaker$RemovalCause: com.google.common.collect.MapMaker$RemovalCause EXPIRED>;

        virtualinvoke r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: void enqueueNotification(java.lang.Object,int,java.lang.Object,com.google.common.collect.MapMaker$RemovalCause)>(r8, i0, r10, $r21);

        goto label12;

     label09:
        virtualinvoke r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: void recordLockedRead(com.google.common.collect.MapMakerInternalMap$ReferenceEntry)>(r3);

        r11 = r10;

     label10:
        virtualinvoke r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: void unlock()>();

        virtualinvoke r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: void postWriteCleanup()>();

     label11:
        virtualinvoke r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: void postReadCleanup()>();

        return r11;

     label12:
        $r24 = r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: java.util.Queue evictionQueue>;

        interfaceinvoke $r24.<java.util.Queue: boolean remove(java.lang.Object)>(r3);

        $r23 = r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: java.util.Queue expirationQueue>;

        interfaceinvoke $r23.<java.util.Queue: boolean remove(java.lang.Object)>(r3);

        r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: int count> = i1;

        goto label14;

     label13:
        r3 = interfaceinvoke r3.<com.google.common.collect.MapMakerInternalMap$ReferenceEntry: com.google.common.collect.MapMakerInternalMap$ReferenceEntry getNext()>();

        goto label06;

     label14:
        if z9 == 0 goto label16;

        $r16 = new com.google.common.collect.ComputingConcurrentHashMap$ComputingValueReference;

        specialinvoke $r16.<com.google.common.collect.ComputingConcurrentHashMap$ComputingValueReference: void <init>(com.google.common.base.Function)>(r2);

        r29 = $r16;

        if r3 != null goto label15;

        r3 = virtualinvoke r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: com.google.common.collect.MapMakerInternalMap$ReferenceEntry newEntry(java.lang.Object,int,com.google.common.collect.MapMakerInternalMap$ReferenceEntry)>(r1, i0, r7);

        interfaceinvoke r3.<com.google.common.collect.MapMakerInternalMap$ReferenceEntry: void setValueReference(com.google.common.collect.MapMakerInternalMap$ValueReference)>(r29);

        virtualinvoke r6.<java.util.concurrent.atomic.AtomicReferenceArray: void set(int,java.lang.Object)>(i2, r3);

        goto label16;

     label15:
        interfaceinvoke r3.<com.google.common.collect.MapMakerInternalMap$ReferenceEntry: void setValueReference(com.google.common.collect.MapMakerInternalMap$ValueReference)>(r29);

     label16:
        virtualinvoke r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: void unlock()>();

        virtualinvoke r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: void postWriteCleanup()>();

        goto label19;

     label17:
        $r28 := @caughtexception;

        r12 = $r28;

     label18:
        virtualinvoke r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: void unlock()>();

        virtualinvoke r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: void postWriteCleanup()>();

        throw r12;

     label19:
        if z9 == 0 goto label21;

        r30 = virtualinvoke r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: java.lang.Object compute(java.lang.Object,int,com.google.common.collect.MapMakerInternalMap$ReferenceEntry,com.google.common.collect.ComputingConcurrentHashMap$ComputingValueReference)>(r1, i0, r3, r29);

     label20:
        virtualinvoke r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: void postReadCleanup()>();

        return r30;

     label21:
        $z0 = staticinvoke <java.lang.Thread: boolean holdsLock(java.lang.Object)>(r3);

        if $z0 != 0 goto label22;

        $z1 = 1;

        goto label23;

     label22:
        $z1 = 0;

     label23:
        staticinvoke <com.google.common.base.Preconditions: void checkState(boolean,java.lang.Object)>($z1, "Recursive computation");

        $r15 = interfaceinvoke r3.<com.google.common.collect.MapMakerInternalMap$ReferenceEntry: com.google.common.collect.MapMakerInternalMap$ValueReference getValueReference()>();

        r31 = interfaceinvoke $r15.<com.google.common.collect.MapMakerInternalMap$ValueReference: java.lang.Object waitForValue()>();

        if r31 == null goto label01;

        virtualinvoke r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: void recordRead(com.google.common.collect.MapMakerInternalMap$ReferenceEntry)>(r3);

        r32 = r31;

     label24:
        virtualinvoke r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: void postReadCleanup()>();

        return r32;

     label25:
        $r27 := @caughtexception;

        r13 = $r27;

     label26:
        virtualinvoke r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: void postReadCleanup()>();

        throw r13;

        catch java.lang.Throwable from label05 to label10 with label17;
        catch java.lang.Throwable from label12 to label16 with label17;
        catch java.lang.Throwable from label17 to label18 with label17;
        catch java.lang.Throwable from label01 to label02 with label25;
        catch java.lang.Throwable from label03 to label11 with label25;
        catch java.lang.Throwable from label12 to label20 with label25;
        catch java.lang.Throwable from label21 to label24 with label25;
        catch java.lang.Throwable from label25 to label26 with label25;
    }

    java.lang.Object compute(java.lang.Object, int, com.google.common.collect.MapMakerInternalMap$ReferenceEntry, com.google.common.collect.ComputingConcurrentHashMap$ComputingValueReference) throws java.util.concurrent.ExecutionException
    {
        com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment r0;
        java.lang.Object r1, r4, r12, r13;
        int i0;
        com.google.common.collect.MapMakerInternalMap$ReferenceEntry r2, r5;
        com.google.common.collect.ComputingConcurrentHashMap$ComputingValueReference r3;
        long l2;
        java.lang.Throwable r6, r7, $r9, $r11;
        byte $b3, $b4;
        com.google.common.collect.MapMaker$RemovalCause $r10;

        r0 := @this: com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment;

        r1 := @parameter0: java.lang.Object;

        i0 := @parameter1: int;

        r2 := @parameter2: com.google.common.collect.MapMakerInternalMap$ReferenceEntry;

        r3 := @parameter3: com.google.common.collect.ComputingConcurrentHashMap$ComputingValueReference;

        r4 = null;

        staticinvoke <java.lang.System: long nanoTime()>();

        l2 = 0L;

     label01:
        r5 = r2;

        entermonitor r2;

     label02:
        r4 = virtualinvoke r3.<com.google.common.collect.ComputingConcurrentHashMap$ComputingValueReference: java.lang.Object compute(java.lang.Object,int)>(r1, i0);

        l2 = staticinvoke <java.lang.System: long nanoTime()>();

        exitmonitor r5;

     label03:
        goto label06;

     label04:
        $r9 := @caughtexception;

        r6 = $r9;

        exitmonitor r5;

     label05:
        throw r6;

     label06:
        if r4 == null goto label07;

        r12 = virtualinvoke r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: java.lang.Object put(java.lang.Object,int,java.lang.Object,boolean)>(r1, i0, r4, 1);

        if r12 == null goto label07;

        $r10 = <com.google.common.collect.MapMaker$RemovalCause: com.google.common.collect.MapMaker$RemovalCause REPLACED>;

        virtualinvoke r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: void enqueueNotification(java.lang.Object,int,java.lang.Object,com.google.common.collect.MapMaker$RemovalCause)>(r1, i0, r4, $r10);

     label07:
        r13 = r4;

     label08:
        $b3 = l2 cmp 0L;

        if $b3 != 0 goto label09;

        staticinvoke <java.lang.System: long nanoTime()>();

     label09:
        if r4 != null goto label10;

        virtualinvoke r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: boolean clearValue(java.lang.Object,int,com.google.common.collect.MapMakerInternalMap$ValueReference)>(r1, i0, r3);

     label10:
        return r13;

     label11:
        $r11 := @caughtexception;

        r7 = $r11;

     label12:
        $b4 = l2 cmp 0L;

        if $b4 != 0 goto label13;

        staticinvoke <java.lang.System: long nanoTime()>();

     label13:
        if r4 != null goto label14;

        virtualinvoke r0.<com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment: boolean clearValue(java.lang.Object,int,com.google.common.collect.MapMakerInternalMap$ValueReference)>(r1, i0, r3);

     label14:
        throw r7;

        catch java.lang.Throwable from label02 to label03 with label04;
        catch java.lang.Throwable from label04 to label05 with label04;
        catch java.lang.Throwable from label01 to label08 with label11;
        catch java.lang.Throwable from label11 to label12 with label11;
    }
}
